// TODO: Find a highlighter that properly supports the AT&T syntax for x86 assembly.

:source-highlighter: pygments
:pygments-style: default
:stem:
:nofooter:

= An Introduction to SIMD
Jochem Arends

== Part 1

=== Introduction
SIMD (Same Instruction Multiple Data) is a parallel processing technique implemented by many CPUs to perform a single operation on multiple operands simultaneously. SIMD reduces the number of instructions needed to perform a certain task and can increase the speed of a program. SIMD is widely used in domains such as image processing, digital signal processing, and 3D graphics. Note that this is not an introduction to x86_64 assembly language and I do assume that the reader has a basic understanding of x86_64 assembly and is familiar with calling conventions and memory alignment.

=== SIMD Extensions for the x86 Architecture
x86 processors can implement various SIMD extensions such as MMX, SSE, AVX, and FMA. In this document I will give a quick introduction to AVX (Adcvanced Vector Extensions). AVX includes the AVX, AVX2, and AVX-512 extensions. This document won't cover the AVX-512 extension since my CPU does not support that one. When following along with this tutorial, make sure that your CPU supports the AVX and AVX2 extensions or use a virtual machine that supports these.

=== AVX Registers
In addition to the regular registers available on 86_64, AVX introduces 16 new 256-bit registers named `ymm0`-`ymm15`. The lower 128 bits of these registers can be accessed independently and are aliased to `xmm0`-`xmm15`. A 256-bit register can hold up to eight single-precision or up to four double-precision floating-point values. The image below visualizes how multiple data values can be packed into a single register.

.AVX Registers
image::./images/registers.png[AVX Registers, width=50%, align="center"]

=== Scalar Data
The AVX instruction set provides several instruction for working with scalar data. A single-precision or double-precision floating-point value can be moved using the `vmovss` or `vmovsd` instructions respectively. Most AVX instruction that operate on single-precision floating-point data have a double-precision counterpart. The double-precision equilevant of such instructions can most time be obtained by swapping the last 's' of the mnemonic with a 'd'. Arithmetics also can be done using the AVX instruction set. Many AVX instructions use non-destructive source operands. Instead of storing the result in one of the source operands, an additional operand is required that will hold the result of the operation. In order to add two scalar floating-point values, the `vaddss` or `vaddsd` instructions can be used. A lot more arithmetic instruction are available such as `vsubs[s|d]` for subtraction, `vmuls[s|d]` for multiplication, and `vdivs[s|d]` for division. The code snippet below demonstrates how the area of a circle can be calculated using AVX instructions.

[source, nasm]
----
.data
pi: .float 3.14
radius: .float 5.2
area: .float 0.0
.text
scalar_example:
    vmovss  radius(%rip) %xmm0      # load the radius from memory
    vmulss  %xmm0, %xmm0, %xmm0     # square the radius
    vmulss  pi(%rip), %xmm0, %xmm0) # multiply by pi
    vmovss  %xmm0, area(%rip)       # store result in memory
    ret
----

=== Packed Data
In order to move packed single-precision floating-point data, the `vmovaps` or `vmovups` instructions can be used. The `vmovaps` instruction requires memory operands to be aligned on a 16-byte boundary for 256-bit wide operands or a 32-byte boundary for 256-bit wide operands. When not sure whether data is properly aligned, always use the `vmovups` instruction. Just like with scalar data, the AVX instruction set also allows us to perform arithmetic operations on packed data. These instructions have a similar mnemonic as their scalar counterpart but have the suffix `ps` or `pd` instead of `ss` or `sd`. For example, `vaddps` or `vaddpd` can be used to add two packed floating-point values, `vsubp[s|d]` for subtraction, `vmulp[s|d` for multiplication, and `vdivp[s|d]` for division. The image below below displays how when performing an operation on packed data the result will also be stored in the packed format.

.SIMD vs Scalar
image::./images/simd_vs_scalar.png[SIMD vs Scalar, width=50%, align="center"]

=== Scalar to Packed
Sometimes it can be useful to convert a scalar value to packed. The `vbroadcasts[s|d]` instructions copy a scalar value to each element of packed data. When broadcasting a single-precision floating-point value to a 256-bit wide operand, it gets copied eight times since stem:[256 / 32 = 8]. The code snippet below demonstrates how a four component vector can be multiplied by a scalar using AVX instructions.

[source, nasm]
----
.data
.align 32
vec: .double 1.0, 2.0, 3.0, 4.0
res: .double 0.0, 0.0, 0.0, 0.0
num: .double 3.0
.text
packed_example:
    vbroadcastsd num(%rip), %ymm0
    vmulpd vec(%rip), %ymm0, %ymm0
    vmovapd %ymm0, res(%rip)
    ret
----

=== Masking
Packed data can conditionally be moved around with something called a mask. A mask is a packed data operand where for each element the most significant bit determines whether that element gets moved. The `vmaskmovp[s|d]` instructions conditionally load and store packed floating-point data. The first operand contains the source data, the second operand contains the mask data, and the last operand is where result gets stored. When the mask bit is set, its corresponding element in the source operand gets copied into the same element of the destination operand. When the mask bit is cleared a `0` will be written to that element of the destination operand.

== Part 2
=== Project Setup
Now we have covered some instruction, we're ready to write a program that uses the AVX instruction set. For this project I've used CMake and the GCC compiler. It is quite easy to get started with assembly using GCC.
[source, cmake]

----
cmake_minimum_required(VERSION 3.20)

project(simd CXX ASM) 

add_executable(simd main.cpp)
----
with the `S` extension.

== Part 3
Write part 3 here.
